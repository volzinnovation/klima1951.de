<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Data Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

<div class="container mx-auto p-4 md:p-8">
    <header class="text-center mb-8">
        <h1 class="text-4xl font-bold text-gray-900">Weather Data Visualizer</h1>
        <p class="text-lg text-gray-600 mt-2">Explore historical weather data from 1951 to 2024</p>
    </header>

    <main>
        <!-- Controls Section -->
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <!-- City Selection -->
                <div>
                    <label for="city-select" class="block text-sm font-medium text-gray-700 mb-2">Select a City:</label>
                    <select id="city-select" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                        <option>Loading cities...</option>
                    </select>
                </div>

                <!-- Date Range Selection -->
                <div>
                    <label for="start-date" class="block text-sm font-medium text-gray-700 mb-2">Start Date:</label>
                    <input type="date" id="start-date" min="1951-01-01" max="2024-12-31" value="2020-01-01" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                </div>
                <div>
                    <label for="end-date" class="block text-sm font-medium text-gray-700 mb-2">End Date:</label>
                    <input type="date" id="end-date" min="1951-01-01" max="2024-12-31" value="2020-12-31" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                </div>

                <!-- Aggregation Level -->
                <div>
                    <label for="aggregation-select" class="block text-sm font-medium text-gray-700 mb-2">Aggregate Data:</label>
                    <select id="aggregation-select" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                        <option value="monthly">Monthly</option>
                        <option value="yearly">Yearly</option>
                    </select>
                </div>
            </div>

            <!-- Measurement and Regression Toggles -->
            <div class="mt-6">
                <div class="flex flex-wrap items-center gap-4">
                    <p class="text-sm font-medium text-gray-700">Measurements:</p>
                    <div id="measurement-toggles" class="flex flex-wrap gap-x-6 gap-y-2">
                        <!-- Checkboxes will be inserted here by JavaScript -->
                    </div>
                    <div class="flex items-center ml-auto">
                        <input id="regression-toggle" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                        <label for="regression-toggle" class="ml-2 block text-sm text-gray-900">Show Regression Line</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chart Section -->
        <div class="bg-white p-6 rounded-2xl shadow-lg">
            <div id="chart-container" class="relative h-[65vh]">
                <canvas id="weather-chart"></canvas>
                <div id="loader" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden">
                    <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32"></div>
                    <p class="ml-4 text-lg font-semibold text-gray-700">Loading data...</p>
                </div>
            </div>
            <div id="message-area" class="text-center text-red-500 mt-4 font-medium"></div>
        </div>
    </main>

</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // DOM element references
        const citySelect = document.getElementById('city-select');
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        const measurementTogglesContainer = document.getElementById('measurement-toggles');
        const aggregationSelect = document.getElementById('aggregation-select');
        const regressionToggle = document.getElementById('regression-toggle');
        const chartCanvas = document.getElementById('weather-chart');
        const loader = document.getElementById('loader');
        const messageArea = document.getElementById('message-area');

        let weatherChart;
        let allData = {};
        let citiesData = [];

        // Configuration for weather measurements
        const measurementConfig = {
            'tas': { label: 'Avg Temp (°C)', color: 'rgba(255, 99, 132, 1)', yAxisID: 'y' },
            'tasmax': { label: 'Max Temp (°C)', color: 'rgba(255, 0, 0, 1)', yAxisID: 'y' },
            'tasmin': { label: 'Min Temp (°C)', color: 'rgba(0, 0, 255, 1)', yAxisID: 'y' },
            'pr': { label: 'Precipitation (mm)', color: 'rgba(54, 162, 235, 1)', yAxisID: 'y1' },
            'hurs': { label: 'Humidity (%)', color: 'rgba(75, 192, 192, 1)', yAxisID: 'y1' }
        };

        /**
         * Fetches data from a given URL.
         * @param {string} url - The URL to fetch data from.
         * @returns {Promise<any>} A promise that resolves with the JSON data.
         */
        async function fetchData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    // Don't throw here, just return the response to be checked
                    return response;
                }
                return await response.json();
            } catch (error) {
                console.error('Fetch error:', error);
                messageArea.textContent = `Failed to fetch data from ${url}. Please check the console for details.`;
                return null;
            }
        }

        /**
         * Populates the city selection dropdown and sets Berlin as default.
         */
        async function populateCities() {
            const citiesUrl = 'https://raw.githubusercontent.com/volzinnovation/klima1951.de/refs/heads/main/misc/cities.json';
            const data = await fetchData(citiesUrl);
            if (data && data.cities) {
                citiesData = data.cities;
                citySelect.innerHTML = ''; // Clear loading message
                citiesData.forEach((city, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = city.city;
                    citySelect.appendChild(option);
                });

                // Find the index for Berlin to set it as the default
                const berlinIndex = citiesData.findIndex(city => city.city === "Berlin");

                if (berlinIndex !== -1) {
                    citySelect.value = berlinIndex;
                    loadWeatherData(berlinIndex);
                } else {
                    // Fallback to the first city if Berlin is not found
                    loadWeatherData(0);
                }

            } else {
                citySelect.innerHTML = '<option>Could not load cities</option>';
            }
        }

        /**
         * Loads weather data for the selected city, trying nearby coordinates on failure.
         * @param {number} cityIndex - The index of the city in the citiesData array.
         */
        async function loadWeatherData(cityIndex) {
            showLoader();
            messageArea.textContent = ''; // Clear previous messages
            const city = citiesData[cityIndex];
            const baseLon = city.longitude;
            const baseLat = city.latitude;

            // Define the order of attempts
            const attempts = [
                { lon: baseLon, lat: baseLat },
                { lon: baseLon + 1, lat: baseLat },
                { lon: baseLon - 1, lat: baseLat },
                { lon: baseLon, lat: baseLat + 1 },
                { lon: baseLon, lat: baseLat - 1 },
                { lon: baseLon + 1, lat: baseLat - 1 },
            ];

            let data = null;

            for (const attempt of attempts) {
                const dataUrl = `https://raw.githubusercontent.com/volzinnovation/klima1951.de/refs/heads/main/data/json/${attempt.lon}/${attempt.lat}/all1951-2024.json`;
                try {
                    const response = await fetch(dataUrl);
                    if (response.ok) {
                        console.log(`Success: Fetched data for ${city.city} at lon=${attempt.lon}, lat=${attempt.lat}`);
                        data = await response.json();
                        break; // Exit loop on first success
                    } else {
                        console.log(`Attempt failed for lon=${attempt.lon}, lat=${attempt.lat}. Status: ${response.status}`);
                    }
                } catch (error) {
                    console.error(`Error fetching from ${dataUrl}:`, error);
                }
            }

            if (data) {
                allData = data;
                updateChart();
            } else {
                messageArea.textContent = `Could not find weather data for ${city.city} or nearby coordinates after 6 attempts.`;
                allData = {}; // Clear old data
                weatherChart.data.datasets = []; // Clear chart
                weatherChart.update();
            }
            hideLoader();
        }

        /**
         * Initializes the chart with default settings.
         */
        function initializeChart() {
            const ctx = chartCanvas.getContext('2d');
            weatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day'
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (°C)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Precipitation / Humidity'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Updates the chart based on the current user selections.
         */
        function updateChart() {
            if (!allData.time || !weatherChart) return;

            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            const aggregation = aggregationSelect.value;
            const showRegression = regressionToggle.checked;

            const selectedMeasurements = Array.from(document.querySelectorAll('#measurement-toggles input:checked')).map(cb => cb.value);

            const datasets = [];

            const filteredIndices = allData.time.map((ts, index) => {
                const date = new Date(ts / 1_000_000);
                return (date >= startDate && date <= endDate) ? index : -1;
            }).filter(index => index !== -1);

            const timeData = filteredIndices.map(i => new Date(allData.time[i] / 1_000_000));

            selectedMeasurements.forEach(key => {
                const measurementData = filteredIndices.map(i => allData[key][i]);

                let aggregationType = 'avg';
                if (key === 'pr') aggregationType = 'sum';
                else if (key === 'tasmax') aggregationType = 'max';
                else if (key === 'tasmin') aggregationType = 'min';

                const { aggregatedTime, aggregatedData } = aggregateData(timeData, measurementData, aggregation, aggregationType);

                datasets.push({
                    label: measurementConfig[key].label,
                    data: aggregatedTime.map((t, i) => ({ x: t, y: aggregatedData[i] })),
                    borderColor: measurementConfig[key].color,
                    backgroundColor: measurementConfig[key].color.replace('1)', '0.2)'),
                    yAxisID: measurementConfig[key].yAxisID,
                    tension: 0.1,
                    pointRadius: aggregation === 'daily' ? 2 : 4,
                });

                if (showRegression && aggregatedData.length > 1) {
                    const regressionData = calculateLinearRegression(aggregatedTime, aggregatedData);
                    datasets.push({
                        label: `${measurementConfig[key].label} (Trend)`,
                        data: regressionData,
                        borderColor: measurementConfig[key].color.replace('1)', '0.5)'),
                        borderDash: [5, 5],
                        yAxisID: measurementConfig[key].yAxisID,
                        pointRadius: 0,
                        fill: false,
                    });
                }
            });

            weatherChart.data.datasets = datasets;

            let timeUnit = 'day';
            if (aggregation === 'weekly') timeUnit = 'week';
            if (aggregation === 'monthly') timeUnit = 'month';
            if (aggregation === 'yearly') timeUnit = 'year';

            weatherChart.options.scales.x.time.unit = timeUnit;
            weatherChart.update();
        }

        /**
         * Aggregates data based on the selected period and aggregation type.
         * @param {Date[]} times - Array of date objects.
         * @param {number[]} values - Array of measurement values.
         * @param {string} period - Aggregation period ('daily', 'weekly', 'monthly', 'yearly').
         * @param {string} aggregationType - Type of aggregation ('avg', 'sum', 'min', 'max').
         * @returns {{aggregatedTime: Date[], aggregatedData: number[]}} The aggregated data.
         */
        function aggregateData(times, values, period, aggregationType = 'avg') {
            if (period === 'daily') {
                return { aggregatedTime: times, aggregatedData: values };
            }

            const aggregated = {};

            times.forEach((time, index) => {
                let key;
                if (period === 'weekly') {
                    const startOfWeek = new Date(time);
                    startOfWeek.setHours(0,0,0,0);
                    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());
                    key = startOfWeek.toISOString().split('T')[0];
                } else if (period === 'monthly') {
                    key = `${time.getFullYear()}-${String(time.getMonth() + 1).padStart(2, '0')}`;
                } else if (period === 'yearly') {
                    key = time.getFullYear().toString();
                }

                if (!aggregated[key]) {
                    aggregated[key] = { sum: 0, count: 0, min: Infinity, max: -Infinity, time: time };
                }

                const value = values[index];
                aggregated[key].sum += value;
                aggregated[key].count++;
                if(value < aggregated[key].min) aggregated[key].min = value;
                if(value > aggregated[key].max) aggregated[key].max = value;
            });

            const aggregatedTime = [];
            const aggregatedData = [];

            for (const key in aggregated) {
                aggregatedTime.push(aggregated[key].time);
                switch (aggregationType) {
                    case 'sum':
                        aggregatedData.push(aggregated[key].sum);
                        break;
                    case 'min':
                        aggregatedData.push(aggregated[key].min);
                        break;
                    case 'max':
                        aggregatedData.push(aggregated[key].max);
                        break;
                    case 'avg':
                    default:
                        aggregatedData.push(aggregated[key].sum / aggregated[key].count);
                        break;
                }
            }

            return { aggregatedTime, aggregatedData };
        }

        /**
         * Calculates a simple linear regression.
         * @param {Date[]} xValues - The x-values (dates).
         * @param {number[]} yValues - The y-values (measurements).
         * @returns {{x: Date, y: number}[]} The data points for the regression line.
         */
        function calculateLinearRegression(xValues, yValues) {
            const n = xValues.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

            const numericX = xValues.map(d => d.getTime());

            for (let i = 0; i < n; i++) {
                sumX += numericX[i];
                sumY += yValues[i];
                sumXY += numericX[i] * yValues[i];
                sumXX += numericX[i] * numericX[i];
            }

            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            return [
                { x: xValues[0], y: slope * numericX[0] + intercept },
                { x: xValues[n - 1], y: slope * numericX[n - 1] + intercept }
            ];
        }

        /**
         * Populates the measurement toggles.
         */
        function createMeasurementToggles() {
            Object.keys(measurementConfig).forEach(key => {
                const div = document.createElement('div');
                div.className = 'flex items-center';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `toggle-${key}`;
                checkbox.value = key;
                checkbox.className = 'h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded';
                if (key === 'tas') checkbox.checked = true;
                const label = document.createElement('label');
                label.htmlFor = `toggle-${key}`;
                label.textContent = measurementConfig[key].label;
                label.className = 'ml-2 block text-sm text-gray-900';

                div.appendChild(checkbox);
                div.appendChild(label);
                measurementTogglesContainer.appendChild(div);
            });
        }

        /**
         * Shows the loading indicator.
         */
        function showLoader() {
            loader.classList.remove('hidden');
        }

        /**
         * Hides the loading indicator.
         */
        function hideLoader() {
            loader.classList.add('hidden');
        }

        // Event Listeners
        citySelect.addEventListener('change', (e) => loadWeatherData(e.target.value));
        startDateInput.addEventListener('change', updateChart);
        endDateInput.addEventListener('change', updateChart);
        aggregationSelect.addEventListener('change', updateChart);
        regressionToggle.addEventListener('change', updateChart);
        measurementTogglesContainer.addEventListener('change', updateChart);

        // Initial setup
        createMeasurementToggles();
        initializeChart();
        populateCities();
    });
</script>
</body>
</html>
